// *** WARNING: this file was generated by pulumi-language-java. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.kubernetesingressnginx.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.kubernetes.core.v1.inputs.AffinityArgs;
import com.pulumi.kubernetes.core.v1.inputs.ContainerArgs;
import com.pulumi.kubernetes.core.v1.inputs.EnvVarArgs;
import com.pulumi.kubernetes.core.v1.inputs.LifecycleArgs;
import com.pulumi.kubernetes.core.v1.inputs.PodSecurityContextArgs;
import com.pulumi.kubernetes.core.v1.inputs.ProbeArgs;
import com.pulumi.kubernetes.core.v1.inputs.ResourceRequirementsArgs;
import com.pulumi.kubernetes.core.v1.inputs.TolerationArgs;
import com.pulumi.kubernetes.core.v1.inputs.TopologySpreadConstraintArgs;
import com.pulumi.kubernetes.core.v1.inputs.VolumeArgs;
import com.pulumi.kubernetes.core.v1.inputs.VolumeMountArgs;
import com.pulumi.kubernetesingressnginx.inputs.AutoscalingArgs;
import com.pulumi.kubernetesingressnginx.inputs.AutoscalingTemplateArgs;
import com.pulumi.kubernetesingressnginx.inputs.ContollerAdmissionWebhooksArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerCustomTemplateArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerHostPortArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerImageArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerIngressClassResourceArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerMetricsArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerPortArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerPublishServiceArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerScopeArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerServiceArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerTcpArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerUdpArgs;
import com.pulumi.kubernetesingressnginx.inputs.ControllerUpdateStrategyArgs;
import com.pulumi.kubernetesingressnginx.inputs.KedaArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class ControllerArgs extends com.pulumi.resources.ResourceArgs {

    public static final ControllerArgs Empty = new ControllerArgs();

    /**
     * Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers.
     * 
     */
    @Import(name="addHeaders")
    private @Nullable Output<Map<String,Map<String,String>>> addHeaders;

    /**
     * @return Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers.
     * 
     */
    public Optional<Output<Map<String,Map<String,String>>>> addHeaders() {
        return Optional.ofNullable(this.addHeaders);
    }

    @Import(name="admissionWebhooks")
    private @Nullable Output<ContollerAdmissionWebhooksArgs> admissionWebhooks;

    public Optional<Output<ContollerAdmissionWebhooksArgs>> admissionWebhooks() {
        return Optional.ofNullable(this.admissionWebhooks);
    }

    /**
     * Affinity and anti-affinity Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity.
     * 
     */
    @Import(name="affinity")
    private @Nullable Output<AffinityArgs> affinity;

    /**
     * @return Affinity and anti-affinity Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity.
     * 
     */
    public Optional<Output<AffinityArgs>> affinity() {
        return Optional.ofNullable(this.affinity);
    }

    /**
     * This configuration defines if Ingress Controller should allow users to set their own *-snippet annotations, otherwise this is forbidden / dropped when users add those annotations. Global snippets in ConfigMap are still respected.
     * 
     */
    @Import(name="allowSnippetAnnotations")
    private @Nullable Output<Boolean> allowSnippetAnnotations;

    /**
     * @return This configuration defines if Ingress Controller should allow users to set their own *-snippet annotations, otherwise this is forbidden / dropped when users add those annotations. Global snippets in ConfigMap are still respected.
     * 
     */
    public Optional<Output<Boolean>> allowSnippetAnnotations() {
        return Optional.ofNullable(this.allowSnippetAnnotations);
    }

    /**
     * Annotations to be added to the controller Deployment or DaemonSet.
     * 
     */
    @Import(name="annotations")
    private @Nullable Output<Map<String,String>> annotations;

    /**
     * @return Annotations to be added to the controller Deployment or DaemonSet.
     * 
     */
    public Optional<Output<Map<String,String>>> annotations() {
        return Optional.ofNullable(this.annotations);
    }

    /**
     * Mutually exclusive with keda autoscaling.
     * 
     */
    @Import(name="autoscaling")
    private @Nullable Output<AutoscalingArgs> autoscaling;

    /**
     * @return Mutually exclusive with keda autoscaling.
     * 
     */
    public Optional<Output<AutoscalingArgs>> autoscaling() {
        return Optional.ofNullable(this.autoscaling);
    }

    /**
     * Custom or additional autoscaling metrics ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics
     * 
     */
    @Import(name="autoscalingTemplate")
    private @Nullable Output<List<AutoscalingTemplateArgs>> autoscalingTemplate;

    /**
     * @return Custom or additional autoscaling metrics ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics
     * 
     */
    public Optional<Output<List<AutoscalingTemplateArgs>>> autoscalingTemplate() {
        return Optional.ofNullable(this.autoscalingTemplate);
    }

    /**
     * Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/.
     * 
     */
    @Import(name="config")
    private @Nullable Output<Map<String,String>> config;

    /**
     * @return Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/.
     * 
     */
    public Optional<Output<Map<String,String>>> config() {
        return Optional.ofNullable(this.config);
    }

    /**
     * Annotations to be added to the controller config configuration configmap.
     * 
     */
    @Import(name="configAnnotations")
    private @Nullable Output<Map<String,String>> configAnnotations;

    /**
     * @return Annotations to be added to the controller config configuration configmap.
     * 
     */
    public Optional<Output<Map<String,String>>> configAnnotations() {
        return Optional.ofNullable(this.configAnnotations);
    }

    /**
     * Allows customization of the configmap / nginx-configmap namespace.
     * 
     */
    @Import(name="configMapNamespace")
    private @Nullable Output<String> configMapNamespace;

    /**
     * @return Allows customization of the configmap / nginx-configmap namespace.
     * 
     */
    public Optional<Output<String>> configMapNamespace() {
        return Optional.ofNullable(this.configMapNamespace);
    }

    /**
     * Configures the controller container name.
     * 
     */
    @Import(name="containerName")
    private @Nullable Output<String> containerName;

    /**
     * @return Configures the controller container name.
     * 
     */
    public Optional<Output<String>> containerName() {
        return Optional.ofNullable(this.containerName);
    }

    /**
     * Configures the ports the nginx-controller listens on.
     * 
     */
    @Import(name="containerPort")
    private @Nullable Output<ControllerPortArgs> containerPort;

    /**
     * @return Configures the ports the nginx-controller listens on.
     * 
     */
    public Optional<Output<ControllerPortArgs>> containerPort() {
        return Optional.ofNullable(this.containerPort);
    }

    /**
     * Override NGINX template.
     * 
     */
    @Import(name="customTemplate")
    private @Nullable Output<ControllerCustomTemplateArgs> customTemplate;

    /**
     * @return Override NGINX template.
     * 
     */
    public Optional<Output<ControllerCustomTemplateArgs>> customTemplate() {
        return Optional.ofNullable(this.customTemplate);
    }

    /**
     * Optionally customize the pod dnsConfig.
     * 
     */
    @Import(name="dnsConfig")
    private @Nullable Output<Map<String,String>> dnsConfig;

    /**
     * @return Optionally customize the pod dnsConfig.
     * 
     */
    public Optional<Output<Map<String,String>>> dnsConfig() {
        return Optional.ofNullable(this.dnsConfig);
    }

    /**
     * Optionally change this to ClusterFirstWithHostNet in case you have &#39;hostNetwork: true&#39;. By default, while using host network, name resolution uses the host&#39;s DNS. If you wish nginx-controller to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.
     * 
     */
    @Import(name="dnsPolicy")
    private @Nullable Output<String> dnsPolicy;

    /**
     * @return Optionally change this to ClusterFirstWithHostNet in case you have &#39;hostNetwork: true&#39;. By default, while using host network, name resolution uses the host&#39;s DNS. If you wish nginx-controller to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.
     * 
     */
    public Optional<Output<String>> dnsPolicy() {
        return Optional.ofNullable(this.dnsPolicy);
    }

    /**
     * Election ID to use for status update.
     * 
     */
    @Import(name="electionID")
    private @Nullable Output<String> electionID;

    /**
     * @return Election ID to use for status update.
     * 
     */
    public Optional<Output<String>> electionID() {
        return Optional.ofNullable(this.electionID);
    }

    /**
     * Enable mimalloc as a drop-in replacement for malloc. ref: https://github.com/microsoft/mimalloc.
     * 
     */
    @Import(name="enableMimalloc")
    private @Nullable Output<Boolean> enableMimalloc;

    /**
     * @return Enable mimalloc as a drop-in replacement for malloc. ref: https://github.com/microsoft/mimalloc.
     * 
     */
    public Optional<Output<Boolean>> enableMimalloc() {
        return Optional.ofNullable(this.enableMimalloc);
    }

    /**
     * Use an existing PSP instead of creating one.
     * 
     */
    @Import(name="existingPsp")
    private @Nullable Output<String> existingPsp;

    /**
     * @return Use an existing PSP instead of creating one.
     * 
     */
    public Optional<Output<String>> existingPsp() {
        return Optional.ofNullable(this.existingPsp);
    }

    /**
     * Additional command line arguments to pass to nginx-ingress-controller E.g. to specify the default SSL certificate you can use `default-ssl-certificate: &#34;&lt;namespace&gt;/&lt;secret_name&gt;&#34;`.
     * 
     */
    @Import(name="extraArgs")
    private @Nullable Output<Map<String,String>> extraArgs;

    /**
     * @return Additional command line arguments to pass to nginx-ingress-controller E.g. to specify the default SSL certificate you can use `default-ssl-certificate: &#34;&lt;namespace&gt;/&lt;secret_name&gt;&#34;`.
     * 
     */
    public Optional<Output<Map<String,String>>> extraArgs() {
        return Optional.ofNullable(this.extraArgs);
    }

    /**
     * Additional containers to be added to the controller pod. See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.
     * 
     */
    @Import(name="extraContainers")
    private @Nullable Output<List<ContainerArgs>> extraContainers;

    /**
     * @return Additional containers to be added to the controller pod. See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.
     * 
     */
    public Optional<Output<List<ContainerArgs>>> extraContainers() {
        return Optional.ofNullable(this.extraContainers);
    }

    /**
     * Additional environment variables to set.
     * 
     */
    @Import(name="extraEnvs")
    private @Nullable Output<List<EnvVarArgs>> extraEnvs;

    /**
     * @return Additional environment variables to set.
     * 
     */
    public Optional<Output<List<EnvVarArgs>>> extraEnvs() {
        return Optional.ofNullable(this.extraEnvs);
    }

    /**
     * Containers, which are run before the app containers are started. - name: init-myservice   image: busybox   command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;]
     * 
     */
    @Import(name="extraInitContainers")
    private @Nullable Output<List<ContainerArgs>> extraInitContainers;

    /**
     * @return Containers, which are run before the app containers are started. - name: init-myservice   image: busybox   command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;]
     * 
     */
    public Optional<Output<List<ContainerArgs>>> extraInitContainers() {
        return Optional.ofNullable(this.extraInitContainers);
    }

    /**
     * Additional volumeMounts to the controller main container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
     * 
     */
    @Import(name="extraVolumeMounts")
    private @Nullable Output<List<VolumeMountArgs>> extraVolumeMounts;

    /**
     * @return Additional volumeMounts to the controller main container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
     * 
     */
    public Optional<Output<List<VolumeMountArgs>>> extraVolumeMounts() {
        return Optional.ofNullable(this.extraVolumeMounts);
    }

    /**
     * Additional volumes to the controller pod.  - name: copy-portal-skins    emptyDir: {}
     * 
     */
    @Import(name="extraVolumes")
    private @Nullable Output<List<VolumeArgs>> extraVolumes;

    /**
     * @return Additional volumes to the controller pod.  - name: copy-portal-skins    emptyDir: {}
     * 
     */
    public Optional<Output<List<VolumeArgs>>> extraVolumes() {
        return Optional.ofNullable(this.extraVolumes);
    }

    /**
     * Path of the health check endpoint. All requests received on the port defined by the healthz-port parameter are forwarded internally to this path.
     * 
     */
    @Import(name="healthCheckPath")
    private @Nullable Output<String> healthCheckPath;

    /**
     * @return Path of the health check endpoint. All requests received on the port defined by the healthz-port parameter are forwarded internally to this path.
     * 
     */
    public Optional<Output<String>> healthCheckPath() {
        return Optional.ofNullable(this.healthCheckPath);
    }

    /**
     * Address to bind the health check endpoint. It is better to set this option to the internal node address if the ingress nginx controller is running in the hostNetwork: true mode.
     * 
     */
    @Import(name="heathCheckHost")
    private @Nullable Output<String> heathCheckHost;

    /**
     * @return Address to bind the health check endpoint. It is better to set this option to the internal node address if the ingress nginx controller is running in the hostNetwork: true mode.
     * 
     */
    public Optional<Output<String>> heathCheckHost() {
        return Optional.ofNullable(this.heathCheckHost);
    }

    /**
     * Required for use with CNI based kubernetes installations (such as ones set up by kubeadm), since CNI and hostport don&#39;t mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920 is merged.
     * 
     */
    @Import(name="hostNetwork")
    private @Nullable Output<Boolean> hostNetwork;

    /**
     * @return Required for use with CNI based kubernetes installations (such as ones set up by kubeadm), since CNI and hostport don&#39;t mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920 is merged.
     * 
     */
    public Optional<Output<Boolean>> hostNetwork() {
        return Optional.ofNullable(this.hostNetwork);
    }

    /**
     * Use host ports 80 and 443. Disabled by default.
     * 
     */
    @Import(name="hostPort")
    private @Nullable Output<ControllerHostPortArgs> hostPort;

    /**
     * @return Use host ports 80 and 443. Disabled by default.
     * 
     */
    public Optional<Output<ControllerHostPortArgs>> hostPort() {
        return Optional.ofNullable(this.hostPort);
    }

    /**
     * Optionally customize the pod hostname.
     * 
     */
    @Import(name="hostname")
    private @Nullable Output<Map<String,Map<String,String>>> hostname;

    /**
     * @return Optionally customize the pod hostname.
     * 
     */
    public Optional<Output<Map<String,Map<String,String>>>> hostname() {
        return Optional.ofNullable(this.hostname);
    }

    @Import(name="image")
    private @Nullable Output<ControllerImageArgs> image;

    public Optional<Output<ControllerImageArgs>> image() {
        return Optional.ofNullable(this.image);
    }

    /**
     * Process IngressClass per name (additionally as per spec.controller).
     * 
     */
    @Import(name="ingressClassByName")
    private @Nullable Output<Boolean> ingressClassByName;

    /**
     * @return Process IngressClass per name (additionally as per spec.controller).
     * 
     */
    public Optional<Output<Boolean>> ingressClassByName() {
        return Optional.ofNullable(this.ingressClassByName);
    }

    /**
     * This section refers to the creation of the IngressClass resource. IngressClass resources are supported since k8s &gt;= 1.18 and required since k8s &gt;= 1.19
     * 
     */
    @Import(name="ingressClassResource")
    private @Nullable Output<ControllerIngressClassResourceArgs> ingressClassResource;

    /**
     * @return This section refers to the creation of the IngressClass resource. IngressClass resources are supported since k8s &gt;= 1.18 and required since k8s &gt;= 1.19
     * 
     */
    public Optional<Output<ControllerIngressClassResourceArgs>> ingressClassResource() {
        return Optional.ofNullable(this.ingressClassResource);
    }

    /**
     * Mutually exclusive with hpa autoscaling.
     * 
     */
    @Import(name="keda")
    private @Nullable Output<KedaArgs> keda;

    /**
     * @return Mutually exclusive with hpa autoscaling.
     * 
     */
    public Optional<Output<KedaArgs>> keda() {
        return Optional.ofNullable(this.keda);
    }

    /**
     * DaemonSet or Deployment.
     * 
     */
    @Import(name="kind")
    private @Nullable Output<String> kind;

    /**
     * @return DaemonSet or Deployment.
     * 
     */
    public Optional<Output<String>> kind() {
        return Optional.ofNullable(this.kind);
    }

    /**
     * Improve connection draining when ingress controller pod is deleted using a lifecycle hook: With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds to 300, allowing the draining of connections up to five minutes. If the active connections end before that, the pod will terminate gracefully at that time. To effectively take advantage of this feature, the Configmap feature worker-shutdown-timeout new value is 240s instead of 10s.
     * 
     */
    @Import(name="lifecycle")
    private @Nullable Output<LifecycleArgs> lifecycle;

    /**
     * @return Improve connection draining when ingress controller pod is deleted using a lifecycle hook: With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds to 300, allowing the draining of connections up to five minutes. If the active connections end before that, the pod will terminate gracefully at that time. To effectively take advantage of this feature, the Configmap feature worker-shutdown-timeout new value is 240s instead of 10s.
     * 
     */
    public Optional<Output<LifecycleArgs>> lifecycle() {
        return Optional.ofNullable(this.lifecycle);
    }

    /**
     * Liveness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
     * 
     */
    @Import(name="livenessProbe")
    private @Nullable Output<ProbeArgs> livenessProbe;

    /**
     * @return Liveness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
     * 
     */
    public Optional<Output<ProbeArgs>> livenessProbe() {
        return Optional.ofNullable(this.livenessProbe);
    }

    /**
     * Maxmind license key to download GeoLite2 Databases https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases.
     * 
     */
    @Import(name="maxmindLicenseKey")
    private @Nullable Output<String> maxmindLicenseKey;

    /**
     * @return Maxmind license key to download GeoLite2 Databases https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases.
     * 
     */
    public Optional<Output<String>> maxmindLicenseKey() {
        return Optional.ofNullable(this.maxmindLicenseKey);
    }

    @Import(name="metrics")
    private @Nullable Output<ControllerMetricsArgs> metrics;

    public Optional<Output<ControllerMetricsArgs>> metrics() {
        return Optional.ofNullable(this.metrics);
    }

    @Import(name="minAvailable")
    private @Nullable Output<Integer> minAvailable;

    public Optional<Output<Integer>> minAvailable() {
        return Optional.ofNullable(this.minAvailable);
    }

    /**
     * minReadySeconds to avoid killing pods before we are ready.
     * 
     */
    @Import(name="minReadySeconds")
    private @Nullable Output<Integer> minReadySeconds;

    /**
     * @return minReadySeconds to avoid killing pods before we are ready.
     * 
     */
    public Optional<Output<Integer>> minReadySeconds() {
        return Optional.ofNullable(this.minReadySeconds);
    }

    @Import(name="name")
    private @Nullable Output<String> name;

    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * Node labels for controller pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
     * 
     */
    @Import(name="nodeSelector")
    private @Nullable Output<Map<String,String>> nodeSelector;

    /**
     * @return Node labels for controller pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
     * 
     */
    public Optional<Output<Map<String,String>>> nodeSelector() {
        return Optional.ofNullable(this.nodeSelector);
    }

    /**
     * Annotations to be added to controller pods.
     * 
     */
    @Import(name="podAnnotations")
    private @Nullable Output<Map<String,String>> podAnnotations;

    /**
     * @return Annotations to be added to controller pods.
     * 
     */
    public Optional<Output<Map<String,String>>> podAnnotations() {
        return Optional.ofNullable(this.podAnnotations);
    }

    /**
     * labels to add to the pod container metadata.
     * 
     */
    @Import(name="podLabels")
    private @Nullable Output<Map<String,String>> podLabels;

    /**
     * @return labels to add to the pod container metadata.
     * 
     */
    public Optional<Output<Map<String,String>>> podLabels() {
        return Optional.ofNullable(this.podLabels);
    }

    /**
     * Security Context policies for controller pods.
     * 
     */
    @Import(name="podSecurityContext")
    private @Nullable Output<PodSecurityContextArgs> podSecurityContext;

    /**
     * @return Security Context policies for controller pods.
     * 
     */
    public Optional<Output<PodSecurityContextArgs>> podSecurityContext() {
        return Optional.ofNullable(this.podSecurityContext);
    }

    @Import(name="priorityClassName")
    private @Nullable Output<String> priorityClassName;

    public Optional<Output<String>> priorityClassName() {
        return Optional.ofNullable(this.priorityClassName);
    }

    /**
     * Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers.
     * 
     */
    @Import(name="proxySetHeaders")
    private @Nullable Output<Map<String,Map<String,String>>> proxySetHeaders;

    /**
     * @return Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers.
     * 
     */
    public Optional<Output<Map<String,Map<String,String>>>> proxySetHeaders() {
        return Optional.ofNullable(this.proxySetHeaders);
    }

    /**
     * Allows customization of the source of the IP address or FQDN to report in the ingress status field. By default, it reads the information provided by the service. If disable, the status field reports the IP address of the node or nodes where an ingress controller pod is running.
     * 
     */
    @Import(name="publishService")
    private @Nullable Output<ControllerPublishServiceArgs> publishService;

    /**
     * @return Allows customization of the source of the IP address or FQDN to report in the ingress status field. By default, it reads the information provided by the service. If disable, the status field reports the IP address of the node or nodes where an ingress controller pod is running.
     * 
     */
    public Optional<Output<ControllerPublishServiceArgs>> publishService() {
        return Optional.ofNullable(this.publishService);
    }

    /**
     * Readiness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
     * 
     */
    @Import(name="readinessProbe")
    private @Nullable Output<ProbeArgs> readinessProbe;

    /**
     * @return Readiness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
     * 
     */
    public Optional<Output<ProbeArgs>> readinessProbe() {
        return Optional.ofNullable(this.readinessProbe);
    }

    @Import(name="replicaCount")
    private @Nullable Output<Integer> replicaCount;

    public Optional<Output<Integer>> replicaCount() {
        return Optional.ofNullable(this.replicaCount);
    }

    /**
     * Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply.
     * 
     */
    @Import(name="reportNodeInternalIp")
    private @Nullable Output<Boolean> reportNodeInternalIp;

    /**
     * @return Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply.
     * 
     */
    public Optional<Output<Boolean>> reportNodeInternalIp() {
        return Optional.ofNullable(this.reportNodeInternalIp);
    }

    /**
     * Define requests resources to avoid probe issues due to CPU utilization in busy nodes ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903 Ideally, there should be no limits. https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/
     * 
     */
    @Import(name="resources")
    private @Nullable Output<ResourceRequirementsArgs> resources;

    /**
     * @return Define requests resources to avoid probe issues due to CPU utilization in busy nodes ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903 Ideally, there should be no limits. https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/
     * 
     */
    public Optional<Output<ResourceRequirementsArgs>> resources() {
        return Optional.ofNullable(this.resources);
    }

    /**
     * Limit the scope of the controller.
     * 
     */
    @Import(name="scope")
    private @Nullable Output<ControllerScopeArgs> scope;

    /**
     * @return Limit the scope of the controller.
     * 
     */
    public Optional<Output<ControllerScopeArgs>> scope() {
        return Optional.ofNullable(this.scope);
    }

    @Import(name="service")
    private @Nullable Output<ControllerServiceArgs> service;

    public Optional<Output<ControllerServiceArgs>> service() {
        return Optional.ofNullable(this.service);
    }

    /**
     * Startup probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
     * 
     */
    @Import(name="startupProbe")
    private @Nullable Output<ProbeArgs> startupProbe;

    /**
     * @return Startup probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
     * 
     */
    public Optional<Output<ProbeArgs>> startupProbe() {
        return Optional.ofNullable(this.startupProbe);
    }

    /**
     * See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
     * 
     */
    @Import(name="sysctls")
    private @Nullable Output<Map<String,Map<String,String>>> sysctls;

    /**
     * @return See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
     * 
     */
    public Optional<Output<Map<String,Map<String,String>>>> sysctls() {
        return Optional.ofNullable(this.sysctls);
    }

    /**
     * Allows customization of the tcp-services-configmap.
     * 
     */
    @Import(name="tcp")
    private @Nullable Output<ControllerTcpArgs> tcp;

    /**
     * @return Allows customization of the tcp-services-configmap.
     * 
     */
    public Optional<Output<ControllerTcpArgs>> tcp() {
        return Optional.ofNullable(this.tcp);
    }

    /**
     * How long to wait for the drain of connections.
     * 
     */
    @Import(name="terminateGracePeriodSeconds")
    private @Nullable Output<Integer> terminateGracePeriodSeconds;

    /**
     * @return How long to wait for the drain of connections.
     * 
     */
    public Optional<Output<Integer>> terminateGracePeriodSeconds() {
        return Optional.ofNullable(this.terminateGracePeriodSeconds);
    }

    /**
     * Node tolerations for server scheduling to nodes with taints Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
     * 
     */
    @Import(name="tolerations")
    private @Nullable Output<TolerationArgs> tolerations;

    /**
     * @return Node tolerations for server scheduling to nodes with taints Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
     * 
     */
    public Optional<Output<TolerationArgs>> tolerations() {
        return Optional.ofNullable(this.tolerations);
    }

    /**
     * Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/.
     * 
     */
    @Import(name="topologySpreadConstraints")
    private @Nullable Output<List<TopologySpreadConstraintArgs>> topologySpreadConstraints;

    /**
     * @return Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/.
     * 
     */
    public Optional<Output<List<TopologySpreadConstraintArgs>>> topologySpreadConstraints() {
        return Optional.ofNullable(this.topologySpreadConstraints);
    }

    @Import(name="udp")
    private @Nullable Output<ControllerUdpArgs> udp;

    public Optional<Output<ControllerUdpArgs>> udp() {
        return Optional.ofNullable(this.udp);
    }

    /**
     * The update strategy to apply to the Deployment or DaemonSet.
     * 
     */
    @Import(name="updateStrategy")
    private @Nullable Output<ControllerUpdateStrategyArgs> updateStrategy;

    /**
     * @return The update strategy to apply to the Deployment or DaemonSet.
     * 
     */
    public Optional<Output<ControllerUpdateStrategyArgs>> updateStrategy() {
        return Optional.ofNullable(this.updateStrategy);
    }

    /**
     * Process Ingress objects without ingressClass annotation/ingressClassName field. Overrides value for --watch-ingress-without-class flag of the controller binary. Defaults to false.
     * 
     */
    @Import(name="watchIngressWithoutClass")
    private @Nullable Output<Boolean> watchIngressWithoutClass;

    /**
     * @return Process Ingress objects without ingressClass annotation/ingressClassName field. Overrides value for --watch-ingress-without-class flag of the controller binary. Defaults to false.
     * 
     */
    public Optional<Output<Boolean>> watchIngressWithoutClass() {
        return Optional.ofNullable(this.watchIngressWithoutClass);
    }

    private ControllerArgs() {}

    private ControllerArgs(ControllerArgs $) {
        this.addHeaders = $.addHeaders;
        this.admissionWebhooks = $.admissionWebhooks;
        this.affinity = $.affinity;
        this.allowSnippetAnnotations = $.allowSnippetAnnotations;
        this.annotations = $.annotations;
        this.autoscaling = $.autoscaling;
        this.autoscalingTemplate = $.autoscalingTemplate;
        this.config = $.config;
        this.configAnnotations = $.configAnnotations;
        this.configMapNamespace = $.configMapNamespace;
        this.containerName = $.containerName;
        this.containerPort = $.containerPort;
        this.customTemplate = $.customTemplate;
        this.dnsConfig = $.dnsConfig;
        this.dnsPolicy = $.dnsPolicy;
        this.electionID = $.electionID;
        this.enableMimalloc = $.enableMimalloc;
        this.existingPsp = $.existingPsp;
        this.extraArgs = $.extraArgs;
        this.extraContainers = $.extraContainers;
        this.extraEnvs = $.extraEnvs;
        this.extraInitContainers = $.extraInitContainers;
        this.extraVolumeMounts = $.extraVolumeMounts;
        this.extraVolumes = $.extraVolumes;
        this.healthCheckPath = $.healthCheckPath;
        this.heathCheckHost = $.heathCheckHost;
        this.hostNetwork = $.hostNetwork;
        this.hostPort = $.hostPort;
        this.hostname = $.hostname;
        this.image = $.image;
        this.ingressClassByName = $.ingressClassByName;
        this.ingressClassResource = $.ingressClassResource;
        this.keda = $.keda;
        this.kind = $.kind;
        this.lifecycle = $.lifecycle;
        this.livenessProbe = $.livenessProbe;
        this.maxmindLicenseKey = $.maxmindLicenseKey;
        this.metrics = $.metrics;
        this.minAvailable = $.minAvailable;
        this.minReadySeconds = $.minReadySeconds;
        this.name = $.name;
        this.nodeSelector = $.nodeSelector;
        this.podAnnotations = $.podAnnotations;
        this.podLabels = $.podLabels;
        this.podSecurityContext = $.podSecurityContext;
        this.priorityClassName = $.priorityClassName;
        this.proxySetHeaders = $.proxySetHeaders;
        this.publishService = $.publishService;
        this.readinessProbe = $.readinessProbe;
        this.replicaCount = $.replicaCount;
        this.reportNodeInternalIp = $.reportNodeInternalIp;
        this.resources = $.resources;
        this.scope = $.scope;
        this.service = $.service;
        this.startupProbe = $.startupProbe;
        this.sysctls = $.sysctls;
        this.tcp = $.tcp;
        this.terminateGracePeriodSeconds = $.terminateGracePeriodSeconds;
        this.tolerations = $.tolerations;
        this.topologySpreadConstraints = $.topologySpreadConstraints;
        this.udp = $.udp;
        this.updateStrategy = $.updateStrategy;
        this.watchIngressWithoutClass = $.watchIngressWithoutClass;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(ControllerArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private ControllerArgs $;

        public Builder() {
            $ = new ControllerArgs();
        }

        public Builder(ControllerArgs defaults) {
            $ = new ControllerArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param addHeaders Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers.
         * 
         * @return builder
         * 
         */
        public Builder addHeaders(@Nullable Output<Map<String,Map<String,String>>> addHeaders) {
            $.addHeaders = addHeaders;
            return this;
        }

        /**
         * @param addHeaders Will add custom headers before sending response traffic to the client according to: https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/#add-headers.
         * 
         * @return builder
         * 
         */
        public Builder addHeaders(Map<String,Map<String,String>> addHeaders) {
            return addHeaders(Output.of(addHeaders));
        }

        public Builder admissionWebhooks(@Nullable Output<ContollerAdmissionWebhooksArgs> admissionWebhooks) {
            $.admissionWebhooks = admissionWebhooks;
            return this;
        }

        public Builder admissionWebhooks(ContollerAdmissionWebhooksArgs admissionWebhooks) {
            return admissionWebhooks(Output.of(admissionWebhooks));
        }

        /**
         * @param affinity Affinity and anti-affinity Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity.
         * 
         * @return builder
         * 
         */
        public Builder affinity(@Nullable Output<AffinityArgs> affinity) {
            $.affinity = affinity;
            return this;
        }

        /**
         * @param affinity Affinity and anti-affinity Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/#affinity-and-anti-affinity.
         * 
         * @return builder
         * 
         */
        public Builder affinity(AffinityArgs affinity) {
            return affinity(Output.of(affinity));
        }

        /**
         * @param allowSnippetAnnotations This configuration defines if Ingress Controller should allow users to set their own *-snippet annotations, otherwise this is forbidden / dropped when users add those annotations. Global snippets in ConfigMap are still respected.
         * 
         * @return builder
         * 
         */
        public Builder allowSnippetAnnotations(@Nullable Output<Boolean> allowSnippetAnnotations) {
            $.allowSnippetAnnotations = allowSnippetAnnotations;
            return this;
        }

        /**
         * @param allowSnippetAnnotations This configuration defines if Ingress Controller should allow users to set their own *-snippet annotations, otherwise this is forbidden / dropped when users add those annotations. Global snippets in ConfigMap are still respected.
         * 
         * @return builder
         * 
         */
        public Builder allowSnippetAnnotations(Boolean allowSnippetAnnotations) {
            return allowSnippetAnnotations(Output.of(allowSnippetAnnotations));
        }

        /**
         * @param annotations Annotations to be added to the controller Deployment or DaemonSet.
         * 
         * @return builder
         * 
         */
        public Builder annotations(@Nullable Output<Map<String,String>> annotations) {
            $.annotations = annotations;
            return this;
        }

        /**
         * @param annotations Annotations to be added to the controller Deployment or DaemonSet.
         * 
         * @return builder
         * 
         */
        public Builder annotations(Map<String,String> annotations) {
            return annotations(Output.of(annotations));
        }

        /**
         * @param autoscaling Mutually exclusive with keda autoscaling.
         * 
         * @return builder
         * 
         */
        public Builder autoscaling(@Nullable Output<AutoscalingArgs> autoscaling) {
            $.autoscaling = autoscaling;
            return this;
        }

        /**
         * @param autoscaling Mutually exclusive with keda autoscaling.
         * 
         * @return builder
         * 
         */
        public Builder autoscaling(AutoscalingArgs autoscaling) {
            return autoscaling(Output.of(autoscaling));
        }

        /**
         * @param autoscalingTemplate Custom or additional autoscaling metrics ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics
         * 
         * @return builder
         * 
         */
        public Builder autoscalingTemplate(@Nullable Output<List<AutoscalingTemplateArgs>> autoscalingTemplate) {
            $.autoscalingTemplate = autoscalingTemplate;
            return this;
        }

        /**
         * @param autoscalingTemplate Custom or additional autoscaling metrics ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics
         * 
         * @return builder
         * 
         */
        public Builder autoscalingTemplate(List<AutoscalingTemplateArgs> autoscalingTemplate) {
            return autoscalingTemplate(Output.of(autoscalingTemplate));
        }

        /**
         * @param autoscalingTemplate Custom or additional autoscaling metrics ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/#support-for-custom-metrics
         * 
         * @return builder
         * 
         */
        public Builder autoscalingTemplate(AutoscalingTemplateArgs... autoscalingTemplate) {
            return autoscalingTemplate(List.of(autoscalingTemplate));
        }

        /**
         * @param config Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/.
         * 
         * @return builder
         * 
         */
        public Builder config(@Nullable Output<Map<String,String>> config) {
            $.config = config;
            return this;
        }

        /**
         * @param config Will add custom configuration options to Nginx https://kubernetes.github.io/ingress-nginx/user-guide/nginx-configuration/configmap/.
         * 
         * @return builder
         * 
         */
        public Builder config(Map<String,String> config) {
            return config(Output.of(config));
        }

        /**
         * @param configAnnotations Annotations to be added to the controller config configuration configmap.
         * 
         * @return builder
         * 
         */
        public Builder configAnnotations(@Nullable Output<Map<String,String>> configAnnotations) {
            $.configAnnotations = configAnnotations;
            return this;
        }

        /**
         * @param configAnnotations Annotations to be added to the controller config configuration configmap.
         * 
         * @return builder
         * 
         */
        public Builder configAnnotations(Map<String,String> configAnnotations) {
            return configAnnotations(Output.of(configAnnotations));
        }

        /**
         * @param configMapNamespace Allows customization of the configmap / nginx-configmap namespace.
         * 
         * @return builder
         * 
         */
        public Builder configMapNamespace(@Nullable Output<String> configMapNamespace) {
            $.configMapNamespace = configMapNamespace;
            return this;
        }

        /**
         * @param configMapNamespace Allows customization of the configmap / nginx-configmap namespace.
         * 
         * @return builder
         * 
         */
        public Builder configMapNamespace(String configMapNamespace) {
            return configMapNamespace(Output.of(configMapNamespace));
        }

        /**
         * @param containerName Configures the controller container name.
         * 
         * @return builder
         * 
         */
        public Builder containerName(@Nullable Output<String> containerName) {
            $.containerName = containerName;
            return this;
        }

        /**
         * @param containerName Configures the controller container name.
         * 
         * @return builder
         * 
         */
        public Builder containerName(String containerName) {
            return containerName(Output.of(containerName));
        }

        /**
         * @param containerPort Configures the ports the nginx-controller listens on.
         * 
         * @return builder
         * 
         */
        public Builder containerPort(@Nullable Output<ControllerPortArgs> containerPort) {
            $.containerPort = containerPort;
            return this;
        }

        /**
         * @param containerPort Configures the ports the nginx-controller listens on.
         * 
         * @return builder
         * 
         */
        public Builder containerPort(ControllerPortArgs containerPort) {
            return containerPort(Output.of(containerPort));
        }

        /**
         * @param customTemplate Override NGINX template.
         * 
         * @return builder
         * 
         */
        public Builder customTemplate(@Nullable Output<ControllerCustomTemplateArgs> customTemplate) {
            $.customTemplate = customTemplate;
            return this;
        }

        /**
         * @param customTemplate Override NGINX template.
         * 
         * @return builder
         * 
         */
        public Builder customTemplate(ControllerCustomTemplateArgs customTemplate) {
            return customTemplate(Output.of(customTemplate));
        }

        /**
         * @param dnsConfig Optionally customize the pod dnsConfig.
         * 
         * @return builder
         * 
         */
        public Builder dnsConfig(@Nullable Output<Map<String,String>> dnsConfig) {
            $.dnsConfig = dnsConfig;
            return this;
        }

        /**
         * @param dnsConfig Optionally customize the pod dnsConfig.
         * 
         * @return builder
         * 
         */
        public Builder dnsConfig(Map<String,String> dnsConfig) {
            return dnsConfig(Output.of(dnsConfig));
        }

        /**
         * @param dnsPolicy Optionally change this to ClusterFirstWithHostNet in case you have &#39;hostNetwork: true&#39;. By default, while using host network, name resolution uses the host&#39;s DNS. If you wish nginx-controller to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.
         * 
         * @return builder
         * 
         */
        public Builder dnsPolicy(@Nullable Output<String> dnsPolicy) {
            $.dnsPolicy = dnsPolicy;
            return this;
        }

        /**
         * @param dnsPolicy Optionally change this to ClusterFirstWithHostNet in case you have &#39;hostNetwork: true&#39;. By default, while using host network, name resolution uses the host&#39;s DNS. If you wish nginx-controller to keep resolving names inside the k8s network, use ClusterFirstWithHostNet.
         * 
         * @return builder
         * 
         */
        public Builder dnsPolicy(String dnsPolicy) {
            return dnsPolicy(Output.of(dnsPolicy));
        }

        /**
         * @param electionID Election ID to use for status update.
         * 
         * @return builder
         * 
         */
        public Builder electionID(@Nullable Output<String> electionID) {
            $.electionID = electionID;
            return this;
        }

        /**
         * @param electionID Election ID to use for status update.
         * 
         * @return builder
         * 
         */
        public Builder electionID(String electionID) {
            return electionID(Output.of(electionID));
        }

        /**
         * @param enableMimalloc Enable mimalloc as a drop-in replacement for malloc. ref: https://github.com/microsoft/mimalloc.
         * 
         * @return builder
         * 
         */
        public Builder enableMimalloc(@Nullable Output<Boolean> enableMimalloc) {
            $.enableMimalloc = enableMimalloc;
            return this;
        }

        /**
         * @param enableMimalloc Enable mimalloc as a drop-in replacement for malloc. ref: https://github.com/microsoft/mimalloc.
         * 
         * @return builder
         * 
         */
        public Builder enableMimalloc(Boolean enableMimalloc) {
            return enableMimalloc(Output.of(enableMimalloc));
        }

        /**
         * @param existingPsp Use an existing PSP instead of creating one.
         * 
         * @return builder
         * 
         */
        public Builder existingPsp(@Nullable Output<String> existingPsp) {
            $.existingPsp = existingPsp;
            return this;
        }

        /**
         * @param existingPsp Use an existing PSP instead of creating one.
         * 
         * @return builder
         * 
         */
        public Builder existingPsp(String existingPsp) {
            return existingPsp(Output.of(existingPsp));
        }

        /**
         * @param extraArgs Additional command line arguments to pass to nginx-ingress-controller E.g. to specify the default SSL certificate you can use `default-ssl-certificate: &#34;&lt;namespace&gt;/&lt;secret_name&gt;&#34;`.
         * 
         * @return builder
         * 
         */
        public Builder extraArgs(@Nullable Output<Map<String,String>> extraArgs) {
            $.extraArgs = extraArgs;
            return this;
        }

        /**
         * @param extraArgs Additional command line arguments to pass to nginx-ingress-controller E.g. to specify the default SSL certificate you can use `default-ssl-certificate: &#34;&lt;namespace&gt;/&lt;secret_name&gt;&#34;`.
         * 
         * @return builder
         * 
         */
        public Builder extraArgs(Map<String,String> extraArgs) {
            return extraArgs(Output.of(extraArgs));
        }

        /**
         * @param extraContainers Additional containers to be added to the controller pod. See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.
         * 
         * @return builder
         * 
         */
        public Builder extraContainers(@Nullable Output<List<ContainerArgs>> extraContainers) {
            $.extraContainers = extraContainers;
            return this;
        }

        /**
         * @param extraContainers Additional containers to be added to the controller pod. See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.
         * 
         * @return builder
         * 
         */
        public Builder extraContainers(List<ContainerArgs> extraContainers) {
            return extraContainers(Output.of(extraContainers));
        }

        /**
         * @param extraContainers Additional containers to be added to the controller pod. See https://github.com/lemonldap-ng-controller/lemonldap-ng-controller as example.
         * 
         * @return builder
         * 
         */
        public Builder extraContainers(ContainerArgs... extraContainers) {
            return extraContainers(List.of(extraContainers));
        }

        /**
         * @param extraEnvs Additional environment variables to set.
         * 
         * @return builder
         * 
         */
        public Builder extraEnvs(@Nullable Output<List<EnvVarArgs>> extraEnvs) {
            $.extraEnvs = extraEnvs;
            return this;
        }

        /**
         * @param extraEnvs Additional environment variables to set.
         * 
         * @return builder
         * 
         */
        public Builder extraEnvs(List<EnvVarArgs> extraEnvs) {
            return extraEnvs(Output.of(extraEnvs));
        }

        /**
         * @param extraEnvs Additional environment variables to set.
         * 
         * @return builder
         * 
         */
        public Builder extraEnvs(EnvVarArgs... extraEnvs) {
            return extraEnvs(List.of(extraEnvs));
        }

        /**
         * @param extraInitContainers Containers, which are run before the app containers are started. - name: init-myservice   image: busybox   command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;]
         * 
         * @return builder
         * 
         */
        public Builder extraInitContainers(@Nullable Output<List<ContainerArgs>> extraInitContainers) {
            $.extraInitContainers = extraInitContainers;
            return this;
        }

        /**
         * @param extraInitContainers Containers, which are run before the app containers are started. - name: init-myservice   image: busybox   command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;]
         * 
         * @return builder
         * 
         */
        public Builder extraInitContainers(List<ContainerArgs> extraInitContainers) {
            return extraInitContainers(Output.of(extraInitContainers));
        }

        /**
         * @param extraInitContainers Containers, which are run before the app containers are started. - name: init-myservice   image: busybox   command: [&#39;sh&#39;, &#39;-c&#39;, &#39;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#39;]
         * 
         * @return builder
         * 
         */
        public Builder extraInitContainers(ContainerArgs... extraInitContainers) {
            return extraInitContainers(List.of(extraInitContainers));
        }

        /**
         * @param extraVolumeMounts Additional volumeMounts to the controller main container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
         * 
         * @return builder
         * 
         */
        public Builder extraVolumeMounts(@Nullable Output<List<VolumeMountArgs>> extraVolumeMounts) {
            $.extraVolumeMounts = extraVolumeMounts;
            return this;
        }

        /**
         * @param extraVolumeMounts Additional volumeMounts to the controller main container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
         * 
         * @return builder
         * 
         */
        public Builder extraVolumeMounts(List<VolumeMountArgs> extraVolumeMounts) {
            return extraVolumeMounts(Output.of(extraVolumeMounts));
        }

        /**
         * @param extraVolumeMounts Additional volumeMounts to the controller main container.  - name: copy-portal-skins    mountPath: /var/lib/lemonldap-ng/portal/skins
         * 
         * @return builder
         * 
         */
        public Builder extraVolumeMounts(VolumeMountArgs... extraVolumeMounts) {
            return extraVolumeMounts(List.of(extraVolumeMounts));
        }

        /**
         * @param extraVolumes Additional volumes to the controller pod.  - name: copy-portal-skins    emptyDir: {}
         * 
         * @return builder
         * 
         */
        public Builder extraVolumes(@Nullable Output<List<VolumeArgs>> extraVolumes) {
            $.extraVolumes = extraVolumes;
            return this;
        }

        /**
         * @param extraVolumes Additional volumes to the controller pod.  - name: copy-portal-skins    emptyDir: {}
         * 
         * @return builder
         * 
         */
        public Builder extraVolumes(List<VolumeArgs> extraVolumes) {
            return extraVolumes(Output.of(extraVolumes));
        }

        /**
         * @param extraVolumes Additional volumes to the controller pod.  - name: copy-portal-skins    emptyDir: {}
         * 
         * @return builder
         * 
         */
        public Builder extraVolumes(VolumeArgs... extraVolumes) {
            return extraVolumes(List.of(extraVolumes));
        }

        /**
         * @param healthCheckPath Path of the health check endpoint. All requests received on the port defined by the healthz-port parameter are forwarded internally to this path.
         * 
         * @return builder
         * 
         */
        public Builder healthCheckPath(@Nullable Output<String> healthCheckPath) {
            $.healthCheckPath = healthCheckPath;
            return this;
        }

        /**
         * @param healthCheckPath Path of the health check endpoint. All requests received on the port defined by the healthz-port parameter are forwarded internally to this path.
         * 
         * @return builder
         * 
         */
        public Builder healthCheckPath(String healthCheckPath) {
            return healthCheckPath(Output.of(healthCheckPath));
        }

        /**
         * @param heathCheckHost Address to bind the health check endpoint. It is better to set this option to the internal node address if the ingress nginx controller is running in the hostNetwork: true mode.
         * 
         * @return builder
         * 
         */
        public Builder heathCheckHost(@Nullable Output<String> heathCheckHost) {
            $.heathCheckHost = heathCheckHost;
            return this;
        }

        /**
         * @param heathCheckHost Address to bind the health check endpoint. It is better to set this option to the internal node address if the ingress nginx controller is running in the hostNetwork: true mode.
         * 
         * @return builder
         * 
         */
        public Builder heathCheckHost(String heathCheckHost) {
            return heathCheckHost(Output.of(heathCheckHost));
        }

        /**
         * @param hostNetwork Required for use with CNI based kubernetes installations (such as ones set up by kubeadm), since CNI and hostport don&#39;t mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920 is merged.
         * 
         * @return builder
         * 
         */
        public Builder hostNetwork(@Nullable Output<Boolean> hostNetwork) {
            $.hostNetwork = hostNetwork;
            return this;
        }

        /**
         * @param hostNetwork Required for use with CNI based kubernetes installations (such as ones set up by kubeadm), since CNI and hostport don&#39;t mix yet. Can be deprecated once https://github.com/kubernetes/kubernetes/issues/23920 is merged.
         * 
         * @return builder
         * 
         */
        public Builder hostNetwork(Boolean hostNetwork) {
            return hostNetwork(Output.of(hostNetwork));
        }

        /**
         * @param hostPort Use host ports 80 and 443. Disabled by default.
         * 
         * @return builder
         * 
         */
        public Builder hostPort(@Nullable Output<ControllerHostPortArgs> hostPort) {
            $.hostPort = hostPort;
            return this;
        }

        /**
         * @param hostPort Use host ports 80 and 443. Disabled by default.
         * 
         * @return builder
         * 
         */
        public Builder hostPort(ControllerHostPortArgs hostPort) {
            return hostPort(Output.of(hostPort));
        }

        /**
         * @param hostname Optionally customize the pod hostname.
         * 
         * @return builder
         * 
         */
        public Builder hostname(@Nullable Output<Map<String,Map<String,String>>> hostname) {
            $.hostname = hostname;
            return this;
        }

        /**
         * @param hostname Optionally customize the pod hostname.
         * 
         * @return builder
         * 
         */
        public Builder hostname(Map<String,Map<String,String>> hostname) {
            return hostname(Output.of(hostname));
        }

        public Builder image(@Nullable Output<ControllerImageArgs> image) {
            $.image = image;
            return this;
        }

        public Builder image(ControllerImageArgs image) {
            return image(Output.of(image));
        }

        /**
         * @param ingressClassByName Process IngressClass per name (additionally as per spec.controller).
         * 
         * @return builder
         * 
         */
        public Builder ingressClassByName(@Nullable Output<Boolean> ingressClassByName) {
            $.ingressClassByName = ingressClassByName;
            return this;
        }

        /**
         * @param ingressClassByName Process IngressClass per name (additionally as per spec.controller).
         * 
         * @return builder
         * 
         */
        public Builder ingressClassByName(Boolean ingressClassByName) {
            return ingressClassByName(Output.of(ingressClassByName));
        }

        /**
         * @param ingressClassResource This section refers to the creation of the IngressClass resource. IngressClass resources are supported since k8s &gt;= 1.18 and required since k8s &gt;= 1.19
         * 
         * @return builder
         * 
         */
        public Builder ingressClassResource(@Nullable Output<ControllerIngressClassResourceArgs> ingressClassResource) {
            $.ingressClassResource = ingressClassResource;
            return this;
        }

        /**
         * @param ingressClassResource This section refers to the creation of the IngressClass resource. IngressClass resources are supported since k8s &gt;= 1.18 and required since k8s &gt;= 1.19
         * 
         * @return builder
         * 
         */
        public Builder ingressClassResource(ControllerIngressClassResourceArgs ingressClassResource) {
            return ingressClassResource(Output.of(ingressClassResource));
        }

        /**
         * @param keda Mutually exclusive with hpa autoscaling.
         * 
         * @return builder
         * 
         */
        public Builder keda(@Nullable Output<KedaArgs> keda) {
            $.keda = keda;
            return this;
        }

        /**
         * @param keda Mutually exclusive with hpa autoscaling.
         * 
         * @return builder
         * 
         */
        public Builder keda(KedaArgs keda) {
            return keda(Output.of(keda));
        }

        /**
         * @param kind DaemonSet or Deployment.
         * 
         * @return builder
         * 
         */
        public Builder kind(@Nullable Output<String> kind) {
            $.kind = kind;
            return this;
        }

        /**
         * @param kind DaemonSet or Deployment.
         * 
         * @return builder
         * 
         */
        public Builder kind(String kind) {
            return kind(Output.of(kind));
        }

        /**
         * @param lifecycle Improve connection draining when ingress controller pod is deleted using a lifecycle hook: With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds to 300, allowing the draining of connections up to five minutes. If the active connections end before that, the pod will terminate gracefully at that time. To effectively take advantage of this feature, the Configmap feature worker-shutdown-timeout new value is 240s instead of 10s.
         * 
         * @return builder
         * 
         */
        public Builder lifecycle(@Nullable Output<LifecycleArgs> lifecycle) {
            $.lifecycle = lifecycle;
            return this;
        }

        /**
         * @param lifecycle Improve connection draining when ingress controller pod is deleted using a lifecycle hook: With this new hook, we increased the default terminationGracePeriodSeconds from 30 seconds to 300, allowing the draining of connections up to five minutes. If the active connections end before that, the pod will terminate gracefully at that time. To effectively take advantage of this feature, the Configmap feature worker-shutdown-timeout new value is 240s instead of 10s.
         * 
         * @return builder
         * 
         */
        public Builder lifecycle(LifecycleArgs lifecycle) {
            return lifecycle(Output.of(lifecycle));
        }

        /**
         * @param livenessProbe Liveness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
         * 
         * @return builder
         * 
         */
        public Builder livenessProbe(@Nullable Output<ProbeArgs> livenessProbe) {
            $.livenessProbe = livenessProbe;
            return this;
        }

        /**
         * @param livenessProbe Liveness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
         * 
         * @return builder
         * 
         */
        public Builder livenessProbe(ProbeArgs livenessProbe) {
            return livenessProbe(Output.of(livenessProbe));
        }

        /**
         * @param maxmindLicenseKey Maxmind license key to download GeoLite2 Databases https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases.
         * 
         * @return builder
         * 
         */
        public Builder maxmindLicenseKey(@Nullable Output<String> maxmindLicenseKey) {
            $.maxmindLicenseKey = maxmindLicenseKey;
            return this;
        }

        /**
         * @param maxmindLicenseKey Maxmind license key to download GeoLite2 Databases https://blog.maxmind.com/2019/12/18/significant-changes-to-accessing-and-using-geolite2-databases.
         * 
         * @return builder
         * 
         */
        public Builder maxmindLicenseKey(String maxmindLicenseKey) {
            return maxmindLicenseKey(Output.of(maxmindLicenseKey));
        }

        public Builder metrics(@Nullable Output<ControllerMetricsArgs> metrics) {
            $.metrics = metrics;
            return this;
        }

        public Builder metrics(ControllerMetricsArgs metrics) {
            return metrics(Output.of(metrics));
        }

        public Builder minAvailable(@Nullable Output<Integer> minAvailable) {
            $.minAvailable = minAvailable;
            return this;
        }

        public Builder minAvailable(Integer minAvailable) {
            return minAvailable(Output.of(minAvailable));
        }

        /**
         * @param minReadySeconds minReadySeconds to avoid killing pods before we are ready.
         * 
         * @return builder
         * 
         */
        public Builder minReadySeconds(@Nullable Output<Integer> minReadySeconds) {
            $.minReadySeconds = minReadySeconds;
            return this;
        }

        /**
         * @param minReadySeconds minReadySeconds to avoid killing pods before we are ready.
         * 
         * @return builder
         * 
         */
        public Builder minReadySeconds(Integer minReadySeconds) {
            return minReadySeconds(Output.of(minReadySeconds));
        }

        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param nodeSelector Node labels for controller pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
         * 
         * @return builder
         * 
         */
        public Builder nodeSelector(@Nullable Output<Map<String,String>> nodeSelector) {
            $.nodeSelector = nodeSelector;
            return this;
        }

        /**
         * @param nodeSelector Node labels for controller pod assignment Ref: https://kubernetes.io/docs/user-guide/node-selection/.
         * 
         * @return builder
         * 
         */
        public Builder nodeSelector(Map<String,String> nodeSelector) {
            return nodeSelector(Output.of(nodeSelector));
        }

        /**
         * @param podAnnotations Annotations to be added to controller pods.
         * 
         * @return builder
         * 
         */
        public Builder podAnnotations(@Nullable Output<Map<String,String>> podAnnotations) {
            $.podAnnotations = podAnnotations;
            return this;
        }

        /**
         * @param podAnnotations Annotations to be added to controller pods.
         * 
         * @return builder
         * 
         */
        public Builder podAnnotations(Map<String,String> podAnnotations) {
            return podAnnotations(Output.of(podAnnotations));
        }

        /**
         * @param podLabels labels to add to the pod container metadata.
         * 
         * @return builder
         * 
         */
        public Builder podLabels(@Nullable Output<Map<String,String>> podLabels) {
            $.podLabels = podLabels;
            return this;
        }

        /**
         * @param podLabels labels to add to the pod container metadata.
         * 
         * @return builder
         * 
         */
        public Builder podLabels(Map<String,String> podLabels) {
            return podLabels(Output.of(podLabels));
        }

        /**
         * @param podSecurityContext Security Context policies for controller pods.
         * 
         * @return builder
         * 
         */
        public Builder podSecurityContext(@Nullable Output<PodSecurityContextArgs> podSecurityContext) {
            $.podSecurityContext = podSecurityContext;
            return this;
        }

        /**
         * @param podSecurityContext Security Context policies for controller pods.
         * 
         * @return builder
         * 
         */
        public Builder podSecurityContext(PodSecurityContextArgs podSecurityContext) {
            return podSecurityContext(Output.of(podSecurityContext));
        }

        public Builder priorityClassName(@Nullable Output<String> priorityClassName) {
            $.priorityClassName = priorityClassName;
            return this;
        }

        public Builder priorityClassName(String priorityClassName) {
            return priorityClassName(Output.of(priorityClassName));
        }

        /**
         * @param proxySetHeaders Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers.
         * 
         * @return builder
         * 
         */
        public Builder proxySetHeaders(@Nullable Output<Map<String,Map<String,String>>> proxySetHeaders) {
            $.proxySetHeaders = proxySetHeaders;
            return this;
        }

        /**
         * @param proxySetHeaders Will add custom headers before sending traffic to backends according to https://github.com/kubernetes/ingress-nginx/tree/main/docs/examples/customization/custom-headers.
         * 
         * @return builder
         * 
         */
        public Builder proxySetHeaders(Map<String,Map<String,String>> proxySetHeaders) {
            return proxySetHeaders(Output.of(proxySetHeaders));
        }

        /**
         * @param publishService Allows customization of the source of the IP address or FQDN to report in the ingress status field. By default, it reads the information provided by the service. If disable, the status field reports the IP address of the node or nodes where an ingress controller pod is running.
         * 
         * @return builder
         * 
         */
        public Builder publishService(@Nullable Output<ControllerPublishServiceArgs> publishService) {
            $.publishService = publishService;
            return this;
        }

        /**
         * @param publishService Allows customization of the source of the IP address or FQDN to report in the ingress status field. By default, it reads the information provided by the service. If disable, the status field reports the IP address of the node or nodes where an ingress controller pod is running.
         * 
         * @return builder
         * 
         */
        public Builder publishService(ControllerPublishServiceArgs publishService) {
            return publishService(Output.of(publishService));
        }

        /**
         * @param readinessProbe Readiness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
         * 
         * @return builder
         * 
         */
        public Builder readinessProbe(@Nullable Output<ProbeArgs> readinessProbe) {
            $.readinessProbe = readinessProbe;
            return this;
        }

        /**
         * @param readinessProbe Readiness probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
         * 
         * @return builder
         * 
         */
        public Builder readinessProbe(ProbeArgs readinessProbe) {
            return readinessProbe(Output.of(readinessProbe));
        }

        public Builder replicaCount(@Nullable Output<Integer> replicaCount) {
            $.replicaCount = replicaCount;
            return this;
        }

        public Builder replicaCount(Integer replicaCount) {
            return replicaCount(Output.of(replicaCount));
        }

        /**
         * @param reportNodeInternalIp Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply.
         * 
         * @return builder
         * 
         */
        public Builder reportNodeInternalIp(@Nullable Output<Boolean> reportNodeInternalIp) {
            $.reportNodeInternalIp = reportNodeInternalIp;
            return this;
        }

        /**
         * @param reportNodeInternalIp Bare-metal considerations via the host network https://kubernetes.github.io/ingress-nginx/deploy/baremetal/#via-the-host-network Ingress status was blank because there is no Service exposing the NGINX Ingress controller in a configuration using the host network, the default --publish-service flag used in standard cloud setups does not apply.
         * 
         * @return builder
         * 
         */
        public Builder reportNodeInternalIp(Boolean reportNodeInternalIp) {
            return reportNodeInternalIp(Output.of(reportNodeInternalIp));
        }

        /**
         * @param resources Define requests resources to avoid probe issues due to CPU utilization in busy nodes ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903 Ideally, there should be no limits. https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/
         * 
         * @return builder
         * 
         */
        public Builder resources(@Nullable Output<ResourceRequirementsArgs> resources) {
            $.resources = resources;
            return this;
        }

        /**
         * @param resources Define requests resources to avoid probe issues due to CPU utilization in busy nodes ref: https://github.com/kubernetes/ingress-nginx/issues/4735#issuecomment-551204903 Ideally, there should be no limits. https://engineering.indeedblog.com/blog/2019/12/cpu-throttling-regression-fix/
         * 
         * @return builder
         * 
         */
        public Builder resources(ResourceRequirementsArgs resources) {
            return resources(Output.of(resources));
        }

        /**
         * @param scope Limit the scope of the controller.
         * 
         * @return builder
         * 
         */
        public Builder scope(@Nullable Output<ControllerScopeArgs> scope) {
            $.scope = scope;
            return this;
        }

        /**
         * @param scope Limit the scope of the controller.
         * 
         * @return builder
         * 
         */
        public Builder scope(ControllerScopeArgs scope) {
            return scope(Output.of(scope));
        }

        public Builder service(@Nullable Output<ControllerServiceArgs> service) {
            $.service = service;
            return this;
        }

        public Builder service(ControllerServiceArgs service) {
            return service(Output.of(service));
        }

        /**
         * @param startupProbe Startup probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
         * 
         * @return builder
         * 
         */
        public Builder startupProbe(@Nullable Output<ProbeArgs> startupProbe) {
            $.startupProbe = startupProbe;
            return this;
        }

        /**
         * @param startupProbe Startup probe values Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-probes.
         * 
         * @return builder
         * 
         */
        public Builder startupProbe(ProbeArgs startupProbe) {
            return startupProbe(Output.of(startupProbe));
        }

        /**
         * @param sysctls See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
         * 
         * @return builder
         * 
         */
        public Builder sysctls(@Nullable Output<Map<String,Map<String,String>>> sysctls) {
            $.sysctls = sysctls;
            return this;
        }

        /**
         * @param sysctls See https://kubernetes.io/docs/tasks/administer-cluster/sysctl-cluster/ for notes on enabling and using sysctls.
         * 
         * @return builder
         * 
         */
        public Builder sysctls(Map<String,Map<String,String>> sysctls) {
            return sysctls(Output.of(sysctls));
        }

        /**
         * @param tcp Allows customization of the tcp-services-configmap.
         * 
         * @return builder
         * 
         */
        public Builder tcp(@Nullable Output<ControllerTcpArgs> tcp) {
            $.tcp = tcp;
            return this;
        }

        /**
         * @param tcp Allows customization of the tcp-services-configmap.
         * 
         * @return builder
         * 
         */
        public Builder tcp(ControllerTcpArgs tcp) {
            return tcp(Output.of(tcp));
        }

        /**
         * @param terminateGracePeriodSeconds How long to wait for the drain of connections.
         * 
         * @return builder
         * 
         */
        public Builder terminateGracePeriodSeconds(@Nullable Output<Integer> terminateGracePeriodSeconds) {
            $.terminateGracePeriodSeconds = terminateGracePeriodSeconds;
            return this;
        }

        /**
         * @param terminateGracePeriodSeconds How long to wait for the drain of connections.
         * 
         * @return builder
         * 
         */
        public Builder terminateGracePeriodSeconds(Integer terminateGracePeriodSeconds) {
            return terminateGracePeriodSeconds(Output.of(terminateGracePeriodSeconds));
        }

        /**
         * @param tolerations Node tolerations for server scheduling to nodes with taints Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
         * 
         * @return builder
         * 
         */
        public Builder tolerations(@Nullable Output<TolerationArgs> tolerations) {
            $.tolerations = tolerations;
            return this;
        }

        /**
         * @param tolerations Node tolerations for server scheduling to nodes with taints Ref: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/.
         * 
         * @return builder
         * 
         */
        public Builder tolerations(TolerationArgs tolerations) {
            return tolerations(Output.of(tolerations));
        }

        /**
         * @param topologySpreadConstraints Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/.
         * 
         * @return builder
         * 
         */
        public Builder topologySpreadConstraints(@Nullable Output<List<TopologySpreadConstraintArgs>> topologySpreadConstraints) {
            $.topologySpreadConstraints = topologySpreadConstraints;
            return this;
        }

        /**
         * @param topologySpreadConstraints Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/.
         * 
         * @return builder
         * 
         */
        public Builder topologySpreadConstraints(List<TopologySpreadConstraintArgs> topologySpreadConstraints) {
            return topologySpreadConstraints(Output.of(topologySpreadConstraints));
        }

        /**
         * @param topologySpreadConstraints Topology spread constraints rely on node labels to identify the topology domain(s) that each Node is in. Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-topology-spread-constraints/.
         * 
         * @return builder
         * 
         */
        public Builder topologySpreadConstraints(TopologySpreadConstraintArgs... topologySpreadConstraints) {
            return topologySpreadConstraints(List.of(topologySpreadConstraints));
        }

        public Builder udp(@Nullable Output<ControllerUdpArgs> udp) {
            $.udp = udp;
            return this;
        }

        public Builder udp(ControllerUdpArgs udp) {
            return udp(Output.of(udp));
        }

        /**
         * @param updateStrategy The update strategy to apply to the Deployment or DaemonSet.
         * 
         * @return builder
         * 
         */
        public Builder updateStrategy(@Nullable Output<ControllerUpdateStrategyArgs> updateStrategy) {
            $.updateStrategy = updateStrategy;
            return this;
        }

        /**
         * @param updateStrategy The update strategy to apply to the Deployment or DaemonSet.
         * 
         * @return builder
         * 
         */
        public Builder updateStrategy(ControllerUpdateStrategyArgs updateStrategy) {
            return updateStrategy(Output.of(updateStrategy));
        }

        /**
         * @param watchIngressWithoutClass Process Ingress objects without ingressClass annotation/ingressClassName field. Overrides value for --watch-ingress-without-class flag of the controller binary. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder watchIngressWithoutClass(@Nullable Output<Boolean> watchIngressWithoutClass) {
            $.watchIngressWithoutClass = watchIngressWithoutClass;
            return this;
        }

        /**
         * @param watchIngressWithoutClass Process Ingress objects without ingressClass annotation/ingressClassName field. Overrides value for --watch-ingress-without-class flag of the controller binary. Defaults to false.
         * 
         * @return builder
         * 
         */
        public Builder watchIngressWithoutClass(Boolean watchIngressWithoutClass) {
            return watchIngressWithoutClass(Output.of(watchIngressWithoutClass));
        }

        public ControllerArgs build() {
            return $;
        }
    }

}
